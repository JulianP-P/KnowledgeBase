# Лекция 1
### Команды:
```
pwd - где находимся
mkdir - создание папки
cd - change directory

touch - для создания и изменения временных меток файла, а также для создания файла
touch -t 05010000 newFile - создание файла с временнойц меткой 5 мая

find - команда поиска
find . -atime +100 - найдем файлы, доступ к которым был больше 100 дней назад
find -exec (команда) {}
{} - передача информации первоначальной команде
потом зачем-то \+ или \;

ls - содержание каталога
ls -l - расширенный вывод

less
more

```
У файла есть три параметра, касающегося времени:
- время создания
- время изменения
- время доступа

Последовательность ключей = последовательность действий

# Лекция 2
## Структура файловой системы
- bin - файлы основных команд (утилит), которые необходимы, когда никакая
другая файловая система еще не смонтирована (например, в
однопользовательском режиме);
- boot - неизменяемые файлы, необходимые для загрузки системы, ядро, загрузчик;
- dev - файлы устройств, хранит узлы устройств;
- etc - файлы конфигурации системы на данном компьютере;
- home - домашние каталоги пользователей;
- var/lib - основные разделяемые библиотеки и модули ядра;
- user/lib - основные разделяемые библиотеки для альтернативных форматов;
- mnt (media) - точку монтирования для временно подключаемых файловых систем;
- root - домашний каталог пользователя root;
- opt - дополнительные пакеты программного обеспечения;
- sbin - основные системные исполняемые файлы (специфичные программы для суперпользователя);
- tmp - временные файлы;
- usr - иерархию второго уровня (специфичные файлы для ОС);
- var - переменные данные.
- proc - виртуальная система ядра для отслеживания процессов.

## Команды
```
cd - в домашнюю диреуторию
cd - - в предыдущую директорию
cd ~user2 - перейти в домашнюю директорию user2
ls -a - скрытые файлы
но лучше ставить
ls -A - не выводит . и ..

более подробная информация о файле
stat file1

Вывод формата файла
file file1

Перевод из одного регистра в другой
tr [:upper:] [:lower:]
```
### Команда less
```
пробел - листание страницами
G -перейти в конец
g - перейти в начало
/ -поиск
n - листание результатов поиска
h - справка о командах
```
### Разбор колонок ls -l

В колонке "права доступу к файла" первый символ означает тип файла: ссылка, директория, файл

Первый набор rwx - владелец файла

Второй набор rwx - Группа владельца файла

Третий набор rwx - Остальные пользователи

Второй столбик - количество ссылок на файл

Третий столбик - владелец файла

Следующий столбик - группа владельца файла

Пятый столбик - размер файла в байтах

Последний столбик - дата последнего изменеия

### Символы подстановки
|Подстановочный символ| Значение|
|---|---|
|*| Соответствует любым символам|
|?|	Соответствует любому единичному символу|
|[символы]|	Соответствует любому символу, который является членом набора символов|
|[!символы]|Соответствует любому символу, который не является членом набора символов|
|[[:класс:]]|	Соответствует любому символу, который является членом указанного класса|

### Ссылки
Жесткие ссылки - позволяют присвоить одному файлу несколько имен, но при этом он в единственном экземпляре будет храниться на диске

Мягкие ссылки (симлинк) - позволяют присвоить одному файлу несколько имен

### cp
```
cp -a source dest - копирование файлов со всеми атрибутами
cp -i source dest - копирование с подтверждением
cp -r source dest - рекурсивное копирование (с файлами из подкаталогов)
cp -u source dest - update копираются только те файлы, которые не существуют или изменялись
cp -v source dest -  максимально подробный вывод
```
### grep
```
Существуют два режима работы: стандартный и расширенный

стандартный - необходимо экранировать символы
grep "\[asas"

расширенный
grep -E "[a-z]"

вывести только то, что совпало (не всю строку)
grep -Eio "[a-z]"

вывести только имя файлов, где встречается регулярка
grep -Eioh "[a-z]" 
```

```
| команда объединения команд
grep -Eioh "[a-zA-Z]" | tr [:upper:] [:lower:] | sort | uniq > file.txt
```

# Лекция 3
### Ссылки
Ссылку можно создавать как на файл, так и на каталог

**Жесткие ссылки**:
- не может указывать на файл, который находится за рамками ос
- не может указывать на директорию
- формально не отличима от самого файла. При выводе ls не удастья различить где файл, а где ссылка.
- Если удаляем жесткую ссылку, то файл не удаляется. Если это последняя ссылка на файл, то удаляется.


**Символичные ссылки**:
- особый тип файла
- отдаленно похож на сущность ярлыка в винде
- можем ссылаться на то, что не находится на диске
- можно делать ссылку на директорию
- неотличима от файла. Если что-то запишем в ссылку, то запись юудет в файл. Если удалим ссылку, то удалится только ссылка.
- если удалим сам файл, ссылка останется, но станет битой
- рекомендуется использовать относительные пути

Пример
```
ln f1 f1_hard - создание жесткой ссылки
ln -s f1 f1_sym - создание мягкой ссылки
ln -s ../f1 f1_sym2 - создание симлинка на директорию

у символический ссылок при выводе ls -l
lrwxrwxrwx
```
Команды
```
type ls - команда позволяет определить, псевдоним это, команда или функция, где хранится

which ls - где находится иполняемый файл команды
Но она может ничего не вернуть, это значит что это встроенная функция оболочки

whatis ls - краткая информация о команде

apropos time - вывод команд, которые что-то делают со временем

alias alias_test='cd /usr/bin; ls -l; cd -'
- позволяет создать псевдоним для команды
unalias alias_text удаление алиаса
alias - вывод всех алиасов

head file.txt - вывод первых 10 строк
tail file.txt - вывод последних 10 строк
tail -f file.txt - вывод последних 10 строк в реальном времени

-n - кол-во строк для вывода
если объединить head и tail, то можно получить режим окна

одновременно выводит и в консоль и в файл
Тут записывает в файл и передает дальше в конвеер
ls /usr/bin/ | tee ls_out | grep zip


```
### Перенаправление
Перенаправление используется только в файл. Если нужно передать информацию в команду, то используется конвеер.

Вывод команды делятся на две категории:
- текстовый вывод результата программы
- сообщение о состоянии программы, ошибки

Существуют стандартный вывод и стандартный вывод ошибок. Они не сохраняются на диске. Стандартный вывод можно далее передать. Также есть стандартный ввод, который связан с утройством ввода (клавиатурой).

Стандартный вывод и стандартная ошибка отображаются на дисплее терминала
пользователя в виде текста.
Ввод и вывод разделен на 3 стандартных потока:
- stdin - стандартный ввод (клавиатура)
- stdout - стандартный вывод (экран)
- stderr - стандартная ошибка (вывод ошибок на экран)
Потоки пронумерованы:
- stdin - 0
- stdout - 1
- stderr - 2

Команды со знаками > или < означают перезапись существующего содержимого
файла:
• > - стандартный вывод
• < - стандартный ввод
• 2> - стандартная ошибка
Команды со знаками >> или << не перезаписывают существующее содержимое
файла, а присоединяют данные к нему:
- >> - стандартный вывод
- << - стандартный ввод
- 2>> - стандартная ошибка

```
Перенаправление стандапртного вывода
ls -l /usr/bin > ls_out

Перенаправление стандартного вывода ошибки
ls -l /usr/binn 2> ls_out

Перенаправить все и сразу.
Пусть стандартный вывод ошибок смотрит туда же, куда и стандартный вывод
ls -l /usr/binn > ls_out 2>&1

Современное решение
ls -l /usr/binn &> ls_out

>> - файл создается или дозаписывается
> - файл перезаписывается

ls -l /usr/bin 2> /dev/null команду выполнить,
 вывести резултат на экран,а ошибку отправить вникуда
```
### Конвеер
```
ls -l /usr/bin | less
В конвеер нельзя передать стандартный вывод ошибки

Существуют пользовательские дескрипторы, помимо трех стандартных

В конвеере можно использовать команды фильтрации. Считаем сколько строк. Сколько уникальных файлов /usr/bin и /bin 
ls -l /usr/bin /bin | sort | uniq | wc -l

ls > less приведет к перезаписыванию команды!
```
# Лекция 4
### Подстановка
```
echo * - выводит название всех файлов в директории
echo /usr/*/share - замена поддиректории звездочкой
echo .* - вывод скрытых файлов (с текущей и родительской)
echo .[!.]?* - вывод скрытых файлов без текущей и родительской
echo ~user - вывод полного пути к домашней директории

echo $((2+2)) - шаблон для работы с математическими операциями. Поддерживается только целочисленная арифметика

echo file_{1..3}_new
file_1_new file_2_new file_3_new

echo 1-{1{1,2}, B{3,4}, C{5,6}}-2
```
```
Переменные окружения
printenv | less


Подстановка
echo $(ls)

ls -l `which rm`
which file.txt - выводит путь до файла

Экранирование
1. Двойные кавычки. Все специальные символы потеряют свое значение в качестве специальных значений. Они будут восприниматься как обычные символы.
Но есть исключения:
- $
- \
- `

2. Одинарные кавычки. Максимальное подавление. Все символы превращаются в обычные

3. \ Обратный слеш. Экранируется олычный слеш

Управлящие последовательности

\t \n \r
\b
\a  - предупреждение (звуковой сигнал)

Командная оболочка
clear - очищать экран
history - история выполнения команд

ctrl + a - в начало строки
ctrl + f
ctrl +
ctrl +

alt + a -
alt + b - на одно слова назад
alt + f - на одно слово вперед

ctrl + d - удаление выделенного курсором символа
ctrl + t - поменять местами выделенный и предыдущий символ

Тоже самое с alt

Из верхнего регистра в нижний - alt + l
Из нижнего регистра в верхний - alt + u

ctrl + k - удаление от курсора до конца строки
ctrl + u - удаление с начала до курсора

ctrl + y - отмена действия


Дополнения
dc
bc

```
# Лекция 5
```
history
!номер команды из истории
!! - выполнение последней команды
ctrl+r и вводим интересующую команду
ctrl + j - ввыводит в терминал нужную команду
ctrl + p ctrl + n листание команд
!?cat - поиск последней команды с cat
```
```
#!/bin/bash -интерпритатор
chmod +x name.sh- разрешения на выполнение пользователю и его группе
. - подставление команды source - прочитать файл, имитировать ввод с клавиатуры
если добавить в папку bin, то при перезагрузке создатстся новая переменная, которая при вызове будет выполнять скрипт
declare -r - переменную нельзя изменить

Переименование файлов, распознание переменной
filename="file1"
touch $filename
mv $filename $filename11 -ошибка
mv $filename ${filename}11 -ок 
```
### Скрипты
```bash
var1 = 0

#Создание функций

function fun1 {
  echo "hello"
  local var1 = 1 #переопределение переменной 
  return
}

# или

fun2 () {
  echo "hello"
  return
}

if [ $y = 4 ] then
# регулярные выражения будут работать только так
# if [[ "$y" =~ ^-?[0-9]+$ ]] then
# if [[ "$INT" -ge "$MIN" && "$INT" -le "$MAX" ]]

else

fi

```

```
mkdir tmp && cd tmp  #вторая команда выполнится только если первая выполнится без ошибки
[ -d temp ] || mkdir temp #  если ошибка, то выполняется вторая команда

команда read
read - r
```

# Лекция 6
### Циклы
```bash
#!/bin/bash

count=1

while [[ $count -le 7 ]]; do
echo $count
count=$((count+1))
done

#общий вид
while cmd; do
cmd;
done

until [[ $count -gt 7 ]]; do
echo $count
count=$((count+1))
done

#общий вид
until cmd; do
cmd;
done

разницы между while и until нет

for i in {A..G}; do
echo $i
done

for (( i=0; i<7; i=i+1 )); do
echo $i
done
```

### Работа с аргументами
```
Указания аргументов
./prog.sh one two
$0 = ./prog.sh 
$1=one
$2=two

Если их больше 9, то используем механизм подстановки
\$100 = ${100}

Получить число аргументов
NoA =$#

Получить все аргументы (с 1 по последнего)
$* - список
"$*" - строка

$@ - список всех аргементов


count=1

while [[ $# -gt 0 ]]; do
echo "$1"
count=$((count+1))
shift - двигаемся по аргументам
done


```
### Работа со строками
```
echo ${test:-"defaut"} или echo ${test:="defaut"}
используем подстановку, если переменная test пустая, то выведется "defaut"

обработка ошибки
echo ${test:?"error"}
если переменная не определенна, то выведется в стандартный вывод error

имена переменных
получить все переменные с определенным префиксом
${!perf*}

хотим вывести только часть значения переменной
ex = "1234567890987654321"
echo ${ex:6:2} с 6 символа по 8 символ
echo ${ex#*90} вывести все, что перед 90 с начала
echo ${ex##*90} вывести все, что перед 90 нежадный с начала

echo ${ex%*90} вывести все, что перед 90 с конца
echo ${ex%%*90} вывести все, что перед 90 нежадный с конца

echo ${ex/90/09} заменет 90 на 09 первое совпадение
echo ${ex//90//09} заменет 90 на 09 во всех случаях
```
```
declare -l ex
bc 
```
