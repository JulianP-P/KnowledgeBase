# Рекурсия

Рекурсия - частичное определенение объекта через самого себя

Рекурсия используется, когда можно выделить самоподобие задачи.

Рекрусия - это способ организации вычислительного процесса, при котором проецедура или функция в хоже выполнения составляющих ее операторов обращается сама к себе.

Недостатки:
- Рекурсивные процедуры приводят к последовательному вызову своих экземпляров. Уходит много памяти.

### Хвостовая рекурсия

Хвостовая рекурсия - специальный случай рекурсии, при котором любой рекурсивный вызов является последней операцией перед возратом функции.

Данный вид рекурсии примечателен тем, что легко может быть изменен на итерацию.
**Не хвостовая рекурсия**
```
recursive integer pure function Factorial(N)
    integer, intent(in) :: N
    
    if (N == 0) then
        Factorial = 1
    else
        Factorial = N * Factorial(N-1)
    end if
end function Factorial
```
**Хвостовая рекурсия**
```
recursive integer pure function Fact_Times(N, Acc)
        integer, intent(in) :: N, Acc
        
        if (N == 0) then
            Fact_Times = Acc
        else
            Fact_Times = Fact_Times(N - 1, Acc * N)
        end if
    end function Fact_Times

    recursive integer pure function Factorial(N)
        integer, intent(in) :: N
        Factrorial = Fac_Times (N, 1)
end function
```


02.11

до 16 декабря

Отличие юникод и утф-8

чтение проводим без явных циклов

доп матеериал для первой дисциплины

Pack - нерегулярный доступ к памяти

# Производные типы данных
```
type :: wheel
  real :: diameter, width   # компонент или поле
  character(len=15) :: material
  integer :: spokes
end type wheel

type(wheel) :: w1 # экземпляр типа wheel или запись
```
Запись - это переменная производного типа данных (стрктурного типа данных)

### Присваивание
Присваивание является единственной встроенной операцией

При присваивание всегда происходит копирование данных

### Конструтор производного типа
```
type :: wheel
  real :: diameter, width   # компонент или поле
  character(len=15) :: material
  integer :: spokes
end type wheel

type(wheel) :: w1 # экземпляр типа wheel или запись
w1 = wheel(1.23, 4.56, 2.0, .false.)
```

### Частные типы
```
module nammals
  type, private :: kangaroo
    real :: 
```

### Скрытые компоненты
```
module nammals
  type :: kangaroo
    private
    real :: weight, length
  end type ::
```

### Присваивание значение компонентам записи

### Массивы структур и структуры массивов

В зависимости от задач стоит использовать или одно или другое. Массив структур использовать удобнее. Но стоит ориентироваться на характер работы с экземплярами. Если работаем чаще со всем массивом экземпляров, то лучше это представлять как структуру массивов. Если чаще работаем с полями одного определенного массива, то лучше использовать массив структур.
```

```
```
```

