"O" - зависимость времени выполнения от кол-ва элеменетов в списке, описывает худший вариант
### Массивы и связанные списки
Массивы подходят для чтения элементов в произвольных позициях, потому что обращение к любому элементу в массиве происходит мгновенно. В связанном списке элементы не хранятся друг с другом, поэтому мгновенно определить позицию i-го элемента в памяти невозможно - нужно обращаться к первому 
элементу, чтобы получить адрес второго элемента, затем обратиться ко второму элементу для получения адреса третьего - и так далее, пока не доберемся до i-го элемента.

- Для поиска удобнее использовать несвязанный список.
- Для вставки и удаления элемнта в список лучше использовать связанный список
- Связанные списки поддерживают только последовательный доступ к памяти
- Простые списки поддерживают поддерживают произвольный доступ к памяти

## Метод решения задач "Разделяй и властвуй"
1. Определяется базовый случай - простейший случай из всех возможных
2. Задача делится до тех пор, пока не будет сведена к базовому случаю

## Алгоритмы поиска
### 1 Бинарный поиск
- При бинарном поиске каждый раз исключается половина чисел, т.к. алгоритм проверяет средний элемент
- В общем случае для cпсика из n элементов бинарный поиск выполняется за `log2(n)`, т.е. O(log n) - логарифмическое время 
- Бинарный поиск работает только на отсортированном списке

Пример: функция, которая возвращает индекс искомого элемента в массиве
```python
def binary_search(list, item)
  # low и high - границы той части списка, в которой выполняется поиск
  low = 0
  high = len(list) - 1

  while low <= high    # пока область поиска не сократилась до одного элемента, проверяем средний элемент
    mid = (low + high)/2
    guess = list[mid]
    if guess == item:  # значение найдено
      return mid
    if guess > item:   # много
      high = mid - 1
    else:              # мало
      low = mid + 1
return None            # значение не существует
```

## Алгоритмы сортировки
### Сортировка выбором
- Список из n элементов проходит n раз, выбирая из списка самый большой (маленький) элемент, перемещает его в новый список
- Сложность О(n^2)

```python
def Sort(arr):
  newArr = []
  for i in range(len(arr)):
    smallest = min(arr)
    newArr.append(arr.pop(smallest))
return newArr
```
