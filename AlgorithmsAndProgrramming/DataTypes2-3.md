## Типы данных [лекция 3]
Данные делятся на **переменные** и **константы**

**kind** - разновидность типа (сколько памяти занимает). Для числовых типов данных этот параметр описывает точность и диапазон изменения. В настоящее время для символьного типа данных существует только одна разновидность

**Всегда проводим инициализацию переменной**

Аннотация - способ задания/написания переменной  

Оператор ` :: ` пишется, если используется какой-то атрибут или присваивание


### Стандартные
- **integer** целый
- **real** вещественный
- **comlex** комплексный
- **logical** логический
- **character** символьный

### Производные
- type (имя типа)


## Правила задания имен
- Латинские буквы (маленькие и большие не различаются)
- Цифры и знаки подчеркивания могут идти со 2-й позиции
- Длина имени не более 63 символов
- Осмысленные имена!

 
### Целочисленный тип
|тип| длина (байт) | диапазон|
|--|--|--|
|integer(1)| 1 | -128 ... 127|
|integer(2)|2|-32 768 ... 32 767 |
|integer(4)|4|$-2^{31}$ ... $2^{31}$-1 |
|integer(8)|8|$-2^{63}$ ... $2^{63}$-1 |


Если разновидность не указана, то разновидность типа отпределяется компилятором

```
! -------------Способы объявления переменных
integer(1) a
integer(2) b
integer i

! -------------Способы объявления констант
integer, parameter :: T0 = 500
integer(2), parameter :: fact = 10100
integer(8), parameter :: QW = 3**20

! -------------Как правильно объявлять переменные и константы
integer, parameter :: I_ = 4
integer(I_), parameter :: IntConst
integer(I_) :: IntVar

index = 1000   ! переменной присвоили значение
a = B'1000101' ! двоичное предстваление
b = O'347'     ! восьмеричное предстваление
c = Z'AAB'     ! шестнадцатеричное предстваление
```
Вычисление выражения при инициализации происходит при компиляции

### Вещественный тип

|тип| длина (байт) |точность| диапазон|
|--|--|--|--|
|real(4)| 4 | 7 |$1.2* 10^{-38}$ ... $3.4*10^{+38}$|
|real(8)|8| 15|$2.3* 10^{-308}$ ... $1.7*10^{+308}$|
|real(16)|16|33|$3.4* 10^{-4932}$ ... $1.1* 10^{+4932}$|

Вещественное число должно хрнитьв себе значащие цифры (мантисса) и порядок

Чисел от 0 до 1 предстваляется примерно столько же сколько от 1 до $3.4*10^{+38}$

```
use ISO_Fortran_Env
! -------------Способы объявления переменных
real(4) :: p = 3.14159
real(4) :: s = 0.00001

real(4) :: A = 6.79E+10
real(4) :: B = -9.0E-10

real(16) :: p1 = 123456789Q4000
real(16) :: p2 = -1.23Q-400

! -------------Вот так следует объявлять переменные и константы
integer, parameter :: R_ = REAL32, R2_ = REAL64, R4_ = REAL128
```
Для представления целого числа в вещественное необходимо брать размерность в два раза больше.

### Комплексный тип
|тип| длина (байт) |точность|
|--|--|--|
|complex(4)| 8 | 7 |
|complex(8)|16| 15|
|complex(16)|32|33|

```
use ISO_Fortran_Env
! -------------Способы объявления переменных
complex(R_) c
complex :: i1 = (0, 1) ! мнимая единица

! ------------- константы
complex, parameter :: z = (2, 3) ! 2+3i
```
В разновидности комплексного числа хранится с какой разновидностью хранится мнимая и вещественная часть числа.
FPU - модуль по работе с плавающей запятой

При арифметических операциях с вещественными числами их значения по порядку не должна быть больше мантисы

### Логический тип [Лекция 4]
|тип| длина (байт) |
|--|--|
|logical(1)| 1|
|logical(2)|2| 
|logical(4)|4|
|logical(8)|8|

Возможные значения `.TRUE.` и `.FALSE.`

Такое разнообразие типов сделано для выравнивания памяти, а также совместимости (например, в другой технологии, с которой мы работаем, под логический тип может быть выделено 4 байта)

## Операции отношения
<, >, == , /=, >=, <=

## Символьный тип
```
character(1) sh ! 1 - это длина, не разновидность
!можно еще так указать
character(len=100) sh1
```
`selected_char_kind` - количесвто памяти для одного символа

`selected_char_kind('ISO_10646')` - 4 байта

`character(len=10, kind=CH_) ISO_string` - создание переменной

`character, parameter :: key = 'A'` - создание символьной константы

### C-строки



## Арифметические операции [лекция 3]
|Операция| Порядок |Выполнение|
|--|--|--|
|**| 1 | <--|
|*|2| -->|
|/|2|-->|
|-,+ (знак числа)|3|<--|
|+|4|-->|
|-|4|-->|

ЕСть специальная функция `epsilon(x)`. Она возвращает минимальное число, которое почувствуется при сложении `1.0 + epsilon(x) != 1`


Операция деления будет целочесленной, если оба операнда целочисленные

Операция будет вещественной, если хотя бы один из операндов вещественный

Отрицательные вещественные числа нельзя возводить в дробную степень (получаются комплексные числа)

### Тернарный оператор (Conditional expression)
`x = x > y ? 0 : 1` или `Merge(0, 1, x > y)`

x > y - логическое выражение

0 - выполняется, если логическое выражение возращает `.TRUE.`

1 - выполняется, если логическое выражение возращает `.FALSE.`

**НО**

`x = x > y ? Foo(x) : Blah(y)`

Что может пойти не так? При выполнении оператора может выполниться и Foo(x), и Blah(y), или может выполняться что-то одно **(это ленивое вычисление)**. Аналогичная ситуация с `if ( foo(z) .or. blah(y))`

### Целочисленная арифметика
Деление целого числа на целое - результат целое `А = 1/3 + 1/3 + 1/3   А = 0`

Запись целого в вещественной форме `А = 1./3. + 1./3. + 1./3.   А = 1.0`

Деление целого числа на 0 - ошибка выполнения `с = 2/3   е = а/с ! деление на 0`

Переполнение значения `integer(1) :: bt = 127; bt = bt + 1 ! bt = -128`

### Вещественная арифметика
Действительные числа предствалены с определенной точностью `a + (b + c) != (a+b) + c`; `(a+b)^2 != a^2 + 2ab + b^2`

Не рекомендуется сравнивать вещественные числа на равенство. Не стоит сравнивать вещественные переменные, которые дошли к своим значениям разными путями.

Приведение от типа с меньшей точностью к большей может привести к погрешности.

Деление вещественного числа на ноль - бесконечность

`a = 1.0/0.0 !infinity`

`b = -1.0/0.0 !-infinity`

Результат Nan "Нет числа" - недопустимый результат
````
real (R_) a, b
a = (-2.0) ** 0.34   Nan
b = asin(2.0)        Nan
````

Проверка на Nan - `IsNan(x)`

### Смешенная арифметика
Автоматическое приведение типов по схемам

`целый -> вещественный -> комплексный`

`от меньшей разрядности  -> к большей`

Исключение -возмедение в степень

### Снижение погрешности
- Не вычитайте близкие числа
- Не делить большие числа по модулю на малые
- Сложение (вычитание) длинной последовательности чисел начинайте с меньших чисел (по модулю)
- Уменьшайте число операций
- Используйте алгоритмы, для которых известны оценки ошибок
- Не сравнивайте на равенство вещественные числа
- Используйте дополнительные переменные для повышения читаемости кода

### Преобразование числовых типов
Приведение к целому типу
`int(a, kind) kind = 1, 2, 4, 8`

Приведение к вещественном типу
`real(a, kind) kind = 4, 8, 16`

Приведение к комплексному типу
`cmplx(a, kind) kind = 4, 8, 16`

