14.09-21.09
# Оглавление
1. [Целочисленный тип](#целочисленный-тип)
2. [Вещественный тип](#вещественный-тип)
3. [Комплексный тип](#комплексный-тип)
4. [Логический тип](#логический-тип-лекция-4)
5. [Арифметические операции](#арифметические-операции-лекция-3)
   1. [Тернарный оператор](##тернарный-оператор-conditional-expression)
   2. [Целочисленная арифметика](#целочисленная-арифметика)
   3. [Вещественная арифметика](#вещественная-арифметика)
   4. [Смешенная арифметика](#смешенная-арифметика)
   5. [Снижение погрешности](#снижение-погрешности)
   6. [Преобразование числовых типов](#преобразование-числовых-типов)
12. [Символьный тип](#cимвольный-тип)
    1. [C-строки](#c-строки)
    2. [Операции со строками](#операции-со-строками)
    3. [Процедуры обработки строк](#процедуры-обработки-строк)
16. [Ввод/вывод](#вводвывод)
17. [Описатели управления](#описатели-управления)
18. [Обработка ошибок](#обработка-ошибок)
19. [Умолчания о типах данных](#умолчания-о-типах-данных)
20. [Элементные функции преобразования типов данных](#элементные-функции-преобразования-типов-данных)

## Типы данных [лекция 3]
Данные делятся на **переменные** и **константы**

**kind** - разновидность типа (сколько памяти занимает). Для числовых типов данных этот параметр описывает точность и диапазон изменения. В настоящее время для символьного типа данных существует только одна разновидность

**Всегда проводим инициализацию переменной**

Аннотация - способ задания/написания переменной  

Оператор ` :: ` пишется, если используется какой-то атрибут или присваивание


### Стандартные
- **integer** целый
- **real** вещественный
- **comlex** комплексный
- **logical** логический
- **character** символьный

### Производные
- type (имя типа)


## Правила задания имен
- Латинские буквы (маленькие и большие не различаются)
- Цифры и знаки подчеркивания могут идти со 2-й позиции
- Длина имени не более 63 символов
- Осмысленные имена!

 
### Целочисленный тип
|тип| длина (байт) | диапазон|
|--|--|--|
|integer(1)| 1 | -128 ... 127|
|integer(2)|2|-32 768 ... 32 767 |
|integer(4)|4|$-2^{31}$ ... $2^{31}$-1 |
|integer(8)|8|$-2^{63}$ ... $2^{63}$-1 |


Если разновидность не указана, то разновидность типа отпределяется компилятором

```
! -------------Способы объявления переменных
integer(1) a
integer(2) b
integer i

! -------------Способы объявления констант
integer, parameter :: T0 = 500
integer(2), parameter :: fact = 10100
integer(8), parameter :: QW = 3**20

! -------------Как правильно объявлять переменные и константы
integer, parameter :: I_ = 4
integer(I_), parameter :: IntConst
integer(I_) :: IntVar

index = 1000   ! переменной присвоили значение
a = B'1000101' ! двоичное предстваление
b = O'347'     ! восьмеричное предстваление
c = Z'AAB'     ! шестнадцатеричное предстваление
```
Вычисление выражения при инициализации происходит при компиляции

### Вещественный тип

|тип| длина (байт) |точность| диапазон|
|--|--|--|--|
|real(4)| 4 | 7 |$1.2* 10^{-38}$ ... $3.4*10^{+38}$|
|real(8)|8| 15|$2.3* 10^{-308}$ ... $1.7*10^{+308}$|
|real(16)|16|33|$3.4* 10^{-4932}$ ... $1.1* 10^{+4932}$|

Вещественное число должно хрнитьв себе значащие цифры (мантисса) и порядок

Чисел от 0 до 1 предстваляется примерно столько же сколько от 1 до $3.4*10^{+38}$

```
use ISO_Fortran_Env
! -------------Способы объявления переменных
real(4) :: p = 3.14159
real(4) :: s = 0.00001

real(4) :: A = 6.79E+10
real(4) :: B = -9.0E-10

real(16) :: p1 = 123456789Q4000
real(16) :: p2 = -1.23Q-400

! -------------Вот так следует объявлять переменные и константы
integer, parameter :: R_ = REAL32, R2_ = REAL64, R4_ = REAL128
```
Для представления целого числа в вещественное необходимо брать размерность в два раза больше.

### Комплексный тип
|тип| длина (байт) |точность|
|--|--|--|
|complex(4)| 8 | 7 |
|complex(8)|16| 15|
|complex(16)|32|33|

```
use ISO_Fortran_Env
! -------------Способы объявления переменных
complex(R_) c
complex :: i1 = (0, 1) ! мнимая единица

! ------------- константы
complex, parameter :: z = (2, 3) ! 2+3i
```
В разновидности комплексного числа хранится с какой разновидностью хранится мнимая и вещественная часть числа.
FPU - модуль по работе с плавающей запятой

При арифметических операциях с вещественными числами их значения по порядку не должна быть больше мантисы

### Логический тип [Лекция 4]
|тип| длина (байт) |
|--|--|
|logical(1)| 1|
|logical(2)|2| 
|logical(4)|4|
|logical(8)|8|

Возможные значения `.TRUE.` и `.FALSE.`

Такое разнообразие типов сделано для выравнивания памяти, а также совместимости (например, в другой технологии, с которой мы работаем, под логический тип может быть выделено 4 байта)

## Операции отношения
<, >, == , /=, >=, <=

## Арифметические операции [лекция 3]
|Операция| Порядок |Выполнение|
|--|--|--|
|**| 1 | <--|
|*|2| -->|
|/|2|-->|
|-,+ (знак числа)|3|<--|
|+|4|-->|
|-|4|-->|

ЕСть специальная функция `epsilon(x)`. Она возвращает минимальное число, которое почувствуется при сложении `1.0 + epsilon(x) != 1`


Операция деления будет целочесленной, если оба операнда целочисленные

Операция будет вещественной, если хотя бы один из операндов вещественный

Отрицательные вещественные числа нельзя возводить в дробную степень (получаются комплексные числа)

### Тернарный оператор (Conditional expression)
`x = x > y ? 0 : 1` или `Merge(0, 1, x > y)`

x > y - логическое выражение

0 - выполняется, если логическое выражение возращает `.TRUE.`

1 - выполняется, если логическое выражение возращает `.FALSE.`

**НО**

`x = x > y ? Foo(x) : Blah(y)`

Что может пойти не так? При выполнении оператора может выполниться и Foo(x), и Blah(y), или может выполняться что-то одно **(это ленивое вычисление)**. Аналогичная ситуация с `if ( foo(z) .or. blah(y))`

### Целочисленная арифметика
Деление целого числа на целое - результат целое `А = 1/3 + 1/3 + 1/3   А = 0`

Запись целого в вещественной форме `А = 1./3. + 1./3. + 1./3.   А = 1.0`

Деление целого числа на 0 - ошибка выполнения `с = 2/3   е = а/с ! деление на 0`

Переполнение значения `integer(1) :: bt = 127; bt = bt + 1 ! bt = -128`

### Вещественная арифметика
Действительные числа предствалены с определенной точностью `a + (b + c) != (a+b) + c`; `(a+b)^2 != a^2 + 2ab + b^2`

Не рекомендуется сравнивать вещественные числа на равенство. Не стоит сравнивать вещественные переменные, которые дошли к своим значениям разными путями.

Приведение от типа с меньшей точностью к большей может привести к погрешности.

Деление вещественного числа на ноль - бесконечность

`a = 1.0/0.0 !infinity`

`b = -1.0/0.0 !-infinity`

Результат Nan "Нет числа" - недопустимый результат
````
real (R_) a, b
a = (-2.0) ** 0.34   Nan
b = asin(2.0)        Nan
````

Проверка на Nan - `IsNan(x)`

### Смешенная арифметика
Автоматическое приведение типов по схемам

`целый -> вещественный -> комплексный`

`от меньшей разрядности  -> к большей`

Исключение -возмедение в степень

### Снижение погрешности
- Не вычитайте близкие числа
- Не делить большие числа по модулю на малые
- Сложение (вычитание) длинной последовательности чисел начинайте с меньших чисел (по модулю)
- Уменьшайте число операций
- Используйте алгоритмы, для которых известны оценки ошибок
- Не сравнивайте на равенство вещественные числа
- Используйте дополнительные переменные для повышения читаемости кода

### Преобразование числовых типов
Приведение к целому типу
`int(a, kind) kind = 1, 2, 4, 8`

Приведение к вещественном типу
`real(a, kind) kind = 4, 8, 16`

Приведение к комплексному типу
`cmplx(a, kind) kind = 4, 8, 16`

## Символьный тип
```
character(1) sh ! 1 - это длина, не разновидность
!можно еще так указать
character(len=100) sh1
```
`selected_char_kind` - количесвто памяти для одного символа

`selected_char_kind('ISO_10646')` - 4 байта

`character(len=10, kind=CH_) ISO_string` - создание переменной

`character, parameter :: key = 'A'` - создание символьной константы


```
character(:), allocatable :: fmt
fmt = "(a,T7, '= ', f6.2)" ! данные в fmt будут размещены во время присваивания, не нужно указывать длину строки
```

```
Len = Len(str)
Len = str%len   ! невычисляемое
kind = str%kind ! невычисляемое
```

### C-строки
Символьная константа заканчивающаяся символом С
```
character(100) cstr
cstr = "Fortran & C++"C ! cstr - C-строка
```
Управляющие символы в с-строках
- \\ слеш
- \а - звуковой сигнал
- \b - на 1 символ назад
- \n - новая строка
- \r - возврат каретки
- \t - горизонтальная табуляция
- и др

## Операции со строками
**// - конкатенация строк**
```
character a*5, b*2, c*20
a = 'AAAAA'
b = '...'
c = a//b//a ! AAAAA...AAAAA
```
**Обращение к подстроке, нумерация с единицы**
```
character (100) str, substr
str = '1234567890'
substr = str(1:3) ! 123
```
 ### Процедуры обработки строк
- `len(str)` - длина строки (невычисляемая процедура)
- `len_trim(str)` - длина строки без хвостовых пробелов
- `index(str,sub)` - номер первого вхождения строки sub в строку str
- `iachar(ch)` - ASCII-код символа
- `achar(code)` - возврат символа с кодом code
- `getcharqq()` - возврат нажатого символа
- `peekcharqq(x)` - определение нажатия клавиши

## Ввод/вывод
Дескрипторы данных
|Дескриптор|Тип|Представление|
|----------|---|-------------|
|nIw[.m]|Целый|Целое число|
|nFw.d|Вещественный|F-форма|
|nEw.d|Вещественный|E-форма|
|nLw|Логический|T и F, .T и .F, .TRUE. и .FALSE.|
|nAw|Символьный|Строка символов|


n - число повторений

w - количество выводимых символов

m - число ведущих нулей

d - число цифр после десятичной точки

```
integer :: a = 10, b = 20, c =30
real :: s = 1.237, p = 1,87342E+10
complex :: k = (0.0, 1.0)
lgical :: st = .true.
character :: key = 'A'

write(*, "(3i4)") a, b, c  ! ^^10^^20^^30
write(*, "(f10.5)") s      ! ^^^1.23700
write(*, "(E10.2)") p      ! ^^0.19E+11
write(*, "(2f5.1)") k      ! ^^0.0^^1.0
write(*, "(L2)") st        ! ^T
write(*, "(A4)") key       ! ^^^A

write(*, "(I4)") 1000000   ! *****ошибка времени выполнения
write(*, "(F5.4)") 123.456 ! ***** ошибка
```

### Описатели управления

- `nX` - вывод n пробелов
- `SP` - вывод знака "+" в числовых данных
- `SS` - не выводить знак "+"
- `S` - восстановлнеие действия дескриптора SS
- `Tn` - абсолютная табуляция
- `TRn` - относительная правая табуляция
- `TLn` - относительная левая табуляция
- `BN` - игнорировать пробелы
- `BZ` - инетерпритировать пробелы как нули
- `/` - переход на следующую строку
- `\` - не переходить на следующиую строку

### Обработка ошибок

```
read( *, *, iostat=iostat)   !если введен недопустимый символ
if (iostat == 0) &
 ! Ошибок не было
```
## Умолчания о типах данных
По умолчанию все объекты программы, имена которых начинаются с букв `i,j,k,l,m,n` или `I,J,K,L,M,N` являеются типом `integer`.

Все остальные объекты имеют тип `real`.

Оператор `implicit` изменяет правила умолчания.

`implicit none` - все имена должны быть объявлены явно

### Элементные функции преобразования типов данных

`int(a, [, kind])` - преобразовывает параметр `а` в целый тип с параметром разновидности kind путем отсечения значения `a` в сторону нуля. Если параметр kind отсутсвует, то результат имеет стандартный целый тип.

`real(a, [, kind])` - преобразовывает параметр `а` в вещественный тип с параметром разновидности kind.

`cmplx(x [, y] [, kind])` - преобразовывает параметры в комплексный тип с параметром разновидности kind. Если kind опущен, то результат complex(4)
- если у хадан, то х - веществення часть комплексного рещультата
- параметр у не может быть задан, если х комплексного типа
- параметр у задан, то он является мнимой частью комплексного рещультата
- Если х и у являются массивами, то они должны быть согласованными.
```
comlex z1, z2
complex(8) z3
z1 = cmplx(3)        ! возвращает 3.0 + 0.0i
z2 = cmplx(3, 4)     ! возвращает 3.0 + 4.0i
z3 = cmplx(3, 4, 8)  ! возвращает 3.0d0 + 4.0d0i
```
