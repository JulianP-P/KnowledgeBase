Лекция 5 - 21.09
# Оглавление
1. [Одномерные массивы](#одномерные-массивы)
      1. [Смещение элементов массива - циклический сдвиг массива ](#смещение-элементов-массива---циклический-сдвиг-массива)
3. [Двумерные массивы](#двумерные-массивы)
   1. [Способы выравнивания](#способы-выравнивания-лекция-6)
  2. [Как обеспечить гарантия отсутсвия перекрытий (overlapping) памяти?](#как-обеспечить-гарантия-отсутсвия-перекрытий-overlapping-памяти)
  3. [Умножение матриц](#умножение-матриц)
  4. [Работа по строкам](#работа-по-строкам)
  5. [Работа по столбцам](#работа-по-столбцам)
  6. [Блочная работа с СОЗУ](#блочная-работа-с-созу)
  7. [Условия вектроризации](#условия-вектроризации)
  8. [Умножение матриц](#умножение-матриц-1)
  9. [Сечения](#сечения)
4. [Сплошные данные](#сплошные-данные)
5. [Векторный индекс](#векторный-индекс)
6. [Динамический массив](#динамический-массив)
7. [Маскированное присваивание](#маскированное-присваивание)
   1. [Оператор where](#оператор-where)
   2. [Оператор do concurrent](#оператор-do-concurrent)
8. [Отображение ранга](#отображение-ранга)
9. [Процедуры обработки массивов](#процедуры-обработки-массивов)
## Одномерные массивы

массив - сплошные данные.

contiguous - сплошной

decriptor - описатель

В некоторых языках программирования в переменной массива хранится адрес первой ячейки. Тогда индекс говорит о смещении относительно этой ячейки памяти. Тогда индексация жестко закреплена с 0.

В Fortran переменная для массива хранит описатель массива, а не адрес ячейки памяти

Массивы являются автоматическими объектами. Управление памятью совершается автоматически. Утечка памяти невозможна.
```
real. allocate :: A(:)
allocate (A(N))
A = [ A, 0, 0, 0, 4]
! при использовании конструтора массива выделяется память и присвавается описателю А,
! старая память высвобождатается
```


```
real A(10)
A = [1, 2]

! границы задаются через константы
integer, parameter :: N = 10
complex ::  B(-N:N) = (0.0, 0.0) ! обнуление

! массив констант
integer, parameter :: INDX(4) = [12, 86, 75, 9]

A = 0 ! обнуление массива

A = (/(0, k=1,5),(2,k=6.10)/) ! циклический список. Будет [0,0,0,0,0,2,2,2,2,2]

A(1) = -2 ! присваивание элементу
A(3) = 2*A(1) + A(5)
```

### Смещение элементов массива - циклический сдвиг массива 

(31:51 вторая запись с лекции)

```
real(10) A
A = CShift(A, 1, -1)

! или [о]конечный сдвиг

A = EOShift(A, 1, 11) ! сдвиг массива A на 1, последнее заполняем числом 11

или сечение массива
A = [A(2:10), 11]
```

## Двумерные массивы

Двумерные массивы развертываются в оперативную памяти начиная с 1 индекса (по левому индексу)

Обязательно обеспечиваем регулярный доступ к памяти! 

regular access - регулярный доступ


**Регулярный доступ** - это доступ к элементам в том порядке, в котором они располагаются в оперативной памяти.

Индексы меняются слева на право (наоборот как в математике)

```
real A (2,4) = [2,5,7,9,0,1,4,8] ! хранение по столбцам

! A(2,4) = [2  7  0  4 &
!           5  9  1  8]

! Но есть способ задать по строкам
real :: A(2,4) = Reshape([2, 7, 0, 4, &
                          5, 9, 1, 8], [2,4], order=[2,1])
```
```
real, allocatable :: A(:, :), B(:, :)
alocate (A(N,M)) ! хранение по столбцам
alocate (B(M,N)) ! хранение по строкам
! Во втором случае обязательно указать:
! B(j,i), j - номер столбца,  i - номер строки
! не стоит представлять это как строки
! записанные в столбцы - представлять это как способ индексации: B(j, i)
```
Нет технологий, которые хранят только по строкам или только по столбцам массивы
Разработчик, определяя назначение индексов, определяет тем самым хранение по строкам или по строкам
При нестандартном назначении индексов обызательно писать об этом в комментарии

### Способы выравнивания [Лекция 6]

`!dir$ attributes align:n::array`

n - кол-во байт на которое нужно выравнивать

array - оператор массива

Опция к компилируемому файлу. Все переменные будут врыавниваться автоматически.
`-alignnbyte`

### Как обеспечить гарантия отсутсвия перекрытий (overlapping) памяти?
```
real(R_), allocatable, target :: A(:) ! адресат
real(R_), pointer :: B(:)             ! ссылка

allocate (A(1:N), source=0)
! A == [0, ..., 0]

! Векторизовать нельзя
do i = 2, N
   A(i) = A(i-1) + 1
end do

B(2:N) => A(1:N-1)
! B(i) == A(i - 1)
! B(2) == A(1)
! B(3) == A(2)
! alias - псевдоним
! перекрытие по памяти у А и В (memory overlapping)

! 
```
### Умножение матриц

```
real :: C(5,3), A(5,3), B(5,3)
...
do j = 1, 3
  do i = 1, 5
    C(i, j) = A(i, j) + B(i, j) // регулярный доступ к памяти
  end do
  ! C(1:5, j) = A(1:5, j) + B(1:5, j)
end do

A == [
1    6    11
2    7    12
3    8    13
4    9    14
5    10   15

A =  [1, 2, 3, 4,  5,  6,  7,  8,  9,  10, 11, 12, 13, 14, 15]
addr  0  4  8  12  16  20  24  28  32  36  40  44  48  52  56
alig  V                             V
vect  V  V  V   V   X   X   X   X   V   V   X   X   V   V   X - в лучшем случае 10 процессорных тактов
```
**array programming (SIMD)** - регулярное программирование позволяет создавать однцу операцию над множеством данных
```
C = A + B

k = 1, 15, 4
C((1:4)) = A((1:4)) + B((1:4))
C((5:8)) = A((5:8)) + B((5:8))
C((9:12)) = A((9:12)) + B((9:12))
C((13:14)) = A((13:14)) + B((13:14))
C((15)) = A((15)) + B((15))

A =  [1, 2, 3, 4,  5,  6,  7,  8,  9,  10, 11, 12, 13, 14, 15]
addr  0  4  8  12  16  20  24  28  32  36  40  44  48  52  56
alig  V                             V
vect  V  V  V   V   V  V   V   V    V   V   V   V   V   V   X - в лучшем случае 5 процессорных тактов
```
## Работа по строкам
Если работаем по строкам:
- храним по столбцам
- договариваемся в комментариях A(j, i)
```
read (In, *) N, M
! A(j, i) -- j - номер столбца, i - номер строки
allocate (A(M,N))
! A (:, 1) - первая строка

! read (In, *) (A(:, i), i = 1, N)
read (In, *)
! см. ex_IO
```

## Работа по столбцам
Если данные хранятся по столбцам, то:
- Стараемся использовать регулярное программирование
- отступы (padding)

#### Отступы
```
real :: C(5 + 3, 3), A(5 + 3, 3), B()

A = [
1    6    11
2    7    12
3    8    13
4    9    14
5    10   15
X    X    X
X    X    X
X    X    X

Каждый столбец выровнен
Обработка массива А(5, 3) проводится за 10 операций
Обработка массива А(8, 3) проводится за 6 операций
```

### Блочная работа с СОЗУ
```
real A(N), B(M), C
do i = 1, N
   do j = 1, M
      c = c + A(i) * B(j)
   end do
end do

или

real A(N, 1), B(1, M), c
c = Sum (MatMul (A, B))
```

### Условия вектроризации
 - Обеспечение регулярного доступа в память
 - Данные должны быть сплошными в памяти
 - Первый элемент каждого вектора должен быть выровнен
 - Не должно быть перекрытий по памяти
 - Не должно быть зависимостей итераций в виде чтение-после-записис

### Умножение матриц

```
! произведение матрицы на матрицу
real :: A(N, M), B(M, K), C(N, K)
C = MatMul (A, B) ! [NxM] * [MxK] = [N x K]

! произведение вектора-строки на матрицу
real :: A(M), B(M, K), C(K)
C = MatMul (A, B) ! [M] * [MxK] = [K]

! произведение матрицы на вектор-столбец
real :: A(N, M), B(M), C(N)
C = MatMul (A, B) ! [NxM] * [M] = [N]

! произведение вектора-столбца на вектор-строку
real :: A(N, 1), B(1, M), C(N, M)
C = MatMul (A, B) ! [Nx1] * [1xM] = [NxM]

! Произведение j - ого столбца матрицы на i-ую строку матрицы (внешним произведением).
real :: A(N, K), B(L, M), C(N, M)
C = MatMul(A(:, j:j), B(i:i, :)) ! [Nx1] * [1xM] = [NxM]

! Разделить массив на положительные и остальные элементы.
real, allocatable :: A(:)
logical, allocatable :: Pos(:)

Pos = A > 0 ! Маска
N = Count(Pos) ! кол-во положительных элементов
A = [Pack(A, Pos), Pack(A, .not. Pos)] ! в первой части массива положительные элементы, во второй - отрицательные
call Sort(A(1:N))

! сортировка каждого четного эл-та
call Sort(A(::2)) ! A(1:N:2) элементы с 1 по N с шагом 2

```

### Сечения

```
A (:, 1) = 0 - сплошная (contiguous) - первый столбец
A (1, :) = 0 - не сплошная, т.к. в памяти элементы хранятся по столбцам - строка

A(2:Mi - 1, 2:Mj - 1) = 2 - не сплошной

Триплет = [i]:[j][:[k]]
i - откуда
j -куда
k - шаг
A(4:8:2)
A(:) - от первого до последнего
```
Как работать с диагональю в двухмерной матрице
```
diag(:) = [(A(i, i), i = 1, N)]

A(4, 4) = [X O O O O X O O O O X O O O O X] == MyData(16)
Diag == MyData(::N+1) == MyData(::5)
Diag(1) == MyData(1) == A(1,1)
Diag(2) == MyData(6) == A(2,2)
Diag(3) == MyData(11) == A(3,3)
Diag(4) == MyData(16) == A(4,4)
```

### Сплошные данные
```
subroutine SortC (Y, N)
  real(:), contiguous :: Y ! непрерывный, сюда нельзя подставить несплошные данные

```
## лекция 7 19.10


Ранг - число измерений массива

Размер - число элементов массива

Форма - ранг и протяженность вдоль каждого измерения

согласованность - ранг,форма и размер совпадают

```
A(3, 5, 8) ! ранг = 3
            ! размер = 3х5х8 = 120
            ! форма 9(3, 5, 8)
```
### Векторный индекс
Векторный индекс - одномерный массив, сожержащий номера избранных элементов массива

**Векторный индекс используется только в исключительных случаях**

Можно использовать, когда меняем местами элементы
```
A = [ 3, 5, 1, 7, 9]
      1  2  3  4  5
v = [1, 3, 4]

A(v) = 0
A = [0, 5, 0, 0, 9]
```

## Динамический массив

Размер массива задается во время работы программы

```
real A(10,20) ! статический массив
real, allocatable :: B(:,:) ! ! динамический массив
```
оператор `allocate` выделяет память под массив

Оператор `deallocate` освобождает память под массив

Функция `allocated` выполняет проверки размещения массива

```
! Если размещаем большой массив, то можно сделать проверку, что размещение прошло успешно
real. allocatable :: A(:, :)
integer ERR_ALLOC

!создали массив 50х50
allocate(A(50,50), STAT=ERR_ALLOC)

if(ERR_ALLOC/=0) stop "Allocation ERROR"

print *, allocated(A) !T
deallocate(A) ! освободить память
print *, allocated(A) ! F
```
```
complex(16) A(-20:20, -30:30)
complex(16), allocateble :: CHILD(:, :)
integer ERR_ALLOC

!унаследовали границу, форму и значения массива А
! если нужно только форму копировать, то можно взять параметр - shape
allocate(CHILD, SOURCE=A, STAT=ERR_ALLOC)

if(ERR_ALLOC/=0) stop "Allocation ERROR"
```
## Маскированное присваивание
### Оператор where
Эффективное выборочное присваивание - замена связки do --- if
```
where (логическое выражение-массив)
  операторы присваивания массивов
elsewhere
  операторы присваивания массивов
end where
```
Пример
```
progream use_where

integer :: A(7) = [1, -2, 3, -4]

where (A<0)
  A=-A
elsewhere
  where (A==0)
    A=5
  elsewhere
    A=A*2
  end where
end where
```
### Оператор do concurrent
concurrent programming - параллельное программирование

concurency - параллелизм
```
do concurrent (integer :: i = 1, N)
    A(i,i) = 0
end do

do concurrent (integer :: i = 1, N)
  blah = foo(i)
  A(i) = blah**2 + cos(blah)
end do
```
## Отображение ранга
```
real, target :: MYDATA (NR*NC)  ! Автоматический массив, адресат, на него можно ссылаться
real, pointer :: MATRIX (:, :)  ! Двухранговый взгляд на MYDATA
real, pointer :: VIES_DIAG(:)   ! Будущая диагональ матрицы

MATRIX(1:NR, 1:NC) => MYDATA    ! Взгляд MATRIX на данные, для переменной MATRIX формируется описатель, который ссылается на тот же участок памяти, что и MYDATA

VIEW_DIAG => MYDATA(1::NR+1)    ! Диагональ матрицы

! Строки, столбцы или блоки матрицы могут быть доступны как сечения MATRIX
```
Наоборот
```
! Данные обязательно должны быть непрерывными
real, contiguous, pointer :: A(:)
real, contiguous, target :: B(:, :)
A(1:size(B))) => B ! Линейный взягляд на массив B
```
## Процедуры обработки массивов
### Переформирование
- RESHAPE - легковесная операция. Представляет матрицу в разных размерах
### Вычисления в массиве
- ALL, ANY
- COUNT
- MAXVAL, MINVAL
- MAXLOC, MINLOC - возвращает массив согласно рангу матрицы, чтобы вернул скаляр, можно указать `MaxLoc(A, dim=1)`. Возвращает индекс внезависмоти от начала индексации в исходном массиве
- PRODUCT
- SUM
### Преобразование
- MERGE
### Вектора и матрицы
- MATMUL
- TRANSPOSE
- DOT_PRODUCT
### Граница, форма, размер
- LBOUND, UBOUND
- SHAPE, SIZE
### Упаковка и распаковка
- PACK
- UNPACK
### Построение
- SPREAD
### Справочные
- ALLOCATED
- IS_CONTIGUOUS
### Сдвиг массивов
- CSHIFT, EOSHIFT
