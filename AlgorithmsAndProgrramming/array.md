Лекция 5 - 21.09
## Одномерные массивы

массив - сплошные данные.

contiguous - сплошной

В некоторых языках программирования в переменной массива хранится адрес первой ячейки. Тогда индекс говорит о смещении относительно этой ячейки памяти. Тогда индексация жестко закреплена с 0.

В Fortran переменная для массива хранит описатель массива, а не адрес ячейки памяти

decriptor - описатель

```
real A(10)
A = [1, 2 ]

! границы задаются через константы
integer, parameter :: N = 10
complex ::  B(-N:N) = (0.0, 0.0) ! обнуление

! массив констант
integer, parameter :: INDX(4) = [12, 86, 75, 9]

A = 0 ! обнуление массива

A = (/(0, k=1,5),(2,k=6.10)/) ! циклический список. Будет [0,0,0,0,0,2,2,2,2,2]

A(1) = -2 ! присваивание элементу
A(3) = 2*A(1) + A(5)
```

### Смещение элементов массива - циклический сдвиг массива (31:51 вторая запись с лекции)

```
real(10) A
A = CShift(A, 1, -1)

! или [о]конечный сдвиг

A = EOShift(A, 1, 11) ! сдвиг массива A на 1, последнее заполняем числом 11

или сечение массива
A = [A(2:10), 11]
```

## Двумерные массивы

Двумерные массивы развертываются в оперативную памяти начиная с 1 индекса (по левому индексу)

Обязательно обеспечиваем регулярный доступ к памяти! 

regular access - регулярный доступ


**Регулярный доступ** - это доступ к элементам в том порядке, в котором они располагаются в оперативной памяти.

Индексы меняются слева на право (наоборот как в математике)

```
real A (2,4) = [2,5,7,9,0,1,4,8] ! хранение по столбцам

! A(2,4) = [2  7  0  4 &
!           5  9  1  8]

! Но есть способ задать по строкам
real :: A(2,4) = Reshape([2, 7, 0, 4, &
                          5, 9, 1, 8], [2,4], order=[2,1])
```
```
real, allocatable :: A(:, :), B(:, :)
alocate (A(N,M)) ! хранение по столбцам
alocate (B(M,N)) ! хранение по строкам
! Во втором случае обязательно указать:
! B(j,i), j - номер столбца,  i - номер строки
! не стоит представлять это как строки
! записанные в столбцы - представлять это как способ индексации: B(j, i)
```
Нет технологий, которые хранят только по строкам или только по столбцам массивы
Разработчик, определяя назначение индексов, определяет тем самым хранение по строкам или по строкам
При нестандартном назначении индексов обызательно писать об этом в комментарии

## Основы векторизации кода
Регулярное программирование позволяет задействовать векторизацию

Показатели качества кода со стороны пользователя:
- код Perf `Perf = 1/T [c^-1]` (code perfomance) - количественный показатель
- потребляемая память Mem (memory consumption) - количественный показатель
- Поддержка современных микроархитектур

ПОказатели качества кода со стороны разработчика:
- Сложность кода Compl (code complexity) - количественный показатель `Compl = LOC, Compl = `

Эффективность кода
- `Prod = Perf / Compl = 1 / (T* Compl)`
  
