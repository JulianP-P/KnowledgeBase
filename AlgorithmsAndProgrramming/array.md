Лекция 5 - 21.09
## Одномерные массивы

массив - сплошные данные.

contiguous - сплошной

В некоторых языках программирования в переменной массива хранится адрес первой ячейки. Тогда индекс говорит о смещении относительно этой ячейки памяти. Тогда индексация жестко закреплена с 0.

В Fortran переменная для массива хранит описатель массива, а не адрес ячейки памяти

decriptor - описатель

```
real A(10)
A = [1, 2 ]

! границы задаются через константы
integer, parameter :: N = 10
complex ::  B(-N:N) = (0.0, 0.0) ! обнуление

! массив констант
integer, parameter :: INDX(4) = [12, 86, 75, 9]

A = 0 ! обнуление массива

A = (/(0, k=1,5),(2,k=6.10)/) ! циклический список. Будет [0,0,0,0,0,2,2,2,2,2]

A(1) = -2 ! присваивание элементу
A(3) = 2*A(1) + A(5)
```

### Смещение элементов массива - циклический сдвиг массива (31:51 вторая запись с лекции)

```
real(10) A
A = CShift(A, 1, -1)

! или [о]конечный сдвиг

A = EOShift(A, 1, 11) ! сдвиг массива A на 1, последнее заполняем числом 11

или сечение массива
A = [A(2:10), 11]
```

## Двумерные массивы

Двумерные массивы развертываются в оперативную памяти начиная с 1 индекса (по левому индексу)

Обязательно обеспечиваем регулярный доступ к памяти! 

regular access - регулярный доступ


**Регулярный доступ** - это доступ к элементам в том порядке, в котором они располагаются в оперативной памяти.

Индексы меняются слева на право (наоборот как в математике)

```
real A (2,4) = [2,5,7,9,0,1,4,8] ! хранение по столбцам

! A(2,4) = [2  7  0  4 &
!           5  9  1  8]

! Но есть способ задать по строкам
real :: A(2,4) = Reshape([2, 7, 0, 4, &
                          5, 9, 1, 8], [2,4], order=[2,1])
```
```
real, allocatable :: A(:, :), B(:, :)
alocate (A(N,M)) ! хранение по столбцам
alocate (B(M,N)) ! хранение по строкам
! Во втором случае обязательно указать:
! B(j,i), j - номер столбца,  i - номер строки
! не стоит представлять это как строки
! записанные в столбцы - представлять это как способ индексации: B(j, i)
```
Нет технологий, которые хранят только по строкам или только по столбцам массивы
Разработчик, определяя назначение индексов, определяет тем самым хранение по строкам или по строкам
При нестандартном назначении индексов обызательно писать об этом в комментарии

### Способы выравнивания [Лекция 6]

`!dir$ attributes align:n::array`

n - кол-во байт на которое нужно выравнивать

array - оператор массива

Опция к компилируемому файлу. Все переменные будут врыавниваться автоматически.
`-alignnbyte`

### Как обеспечить гарантия отсутсвия перекрытий (overlapping) памяти?
```
real(R_), allocatable, target :: A(:) ! адресат
real(R_), pointer :: B(:)             ! ссылка

allocate (A(1:N), source=0)
! A == [0, ..., 0]

! Векторизовать нельзя
do i = 2, N
   A(i) = A(i-1) + 1
end do

B(2:N) => A(1:N-1)
! B(i) == A(i - 1)
! B(2) == A(1)
! B(3) == A(2)
! alias - псевдоним
! перекрытие по памяти у А и В (memory overlapping)

! 
```
### Умножение матриц

```
real :: C(5,3), A(5,3), B(5,3)
...
do j = 1, 3
  do i = 1, 5
    C(i, j) = A(i, j) + B(i, j) // регулярный доступ к памяти
  end do
  ! C(1:5, j) = A(1:5, j) + B(1:5, j)
end do

A == [
1    6    11
2    7    12
3    8    13
4    9    14
5    10   15

A =  [1, 2, 3, 4,  5,  6,  7,  8,  9,  10, 11, 12, 13, 14, 15]
addr  0  4  8  12  16  20  24  28  32  36  40  44  48  52  56
alig  V                             V
vect  V  V  V   V   X   X   X   X   V   V   X   X   V   V   X - в лучшем случае 10 процессорных тактов
```
**array programming (SIMD)** - регулярное программирование позволяет создавать однцу операцию над множеством данных
```
C = A + B

k = 1, 15, 4
C((1:4)) = A((1:4)) + B((1:4))
C((5:8)) = A((5:8)) + B((5:8))
C((9:12)) = A((9:12)) + B((9:12))
C((13:14)) = A((13:14)) + B((13:14))
C((15)) = A((15)) + B((15))

A =  [1, 2, 3, 4,  5,  6,  7,  8,  9,  10, 11, 12, 13, 14, 15]
addr  0  4  8  12  16  20  24  28  32  36  40  44  48  52  56
alig  V                             V
vect  V  V  V   V   V  V   V   V    V   V   V   V   V   V   X - в лучшем случае 5 процессорных тактов
```
## Работа по строкам
Если работаем по строкам:
- храним по столбцам
- договариваемся в комментариях A(j, i)
```
read (In, *) N, M
! A(j, i) -- j - номер столбца, i - номер строки
allocate (A(M,N))
! A (:, 1) - первая строка

! read (In, *) (A(:, i), i = 1, N)
read (In, *)
! см. ex_IO
```

## Работа по столбцам
Если данные хранятся по столбцам, то:
- Стараемся использовать регулярное программирование
- отступы (padding)

#### Отступы
```
real :: C(5 + 3, 3), A(5 + 3, 3), B()

A = [
1    6    11
2    7    12
3    8    13
4    9    14
5    10   15
X    X    X
X    X    X
X    X    X

Каждый столбец выровнен
Обработка массива А(5, 3) проводится за 10 операций
Обработка массива А(8, 3) проводится за 6 операций
```

### Блочная работа с СОЗУ
```
real A(N), B(M), C
do i = 1, N
   do j = 1, M
      c = c + A(i) * B(j)
   end do
end do

или

real A(N, 1), B(1, M), c
c = Sum (MatMul (A, B))
```

### Условия вектроризации
 - Обеспечение регулярного доступа в память
 - Данные должны быть сплошными в памяти
 - Первый элемент каждого вектора должен быть выровнен
 - Не должно быть перекрытий по памяти
 - Не должно быть зависимостей итераций в виде чтение-после-записис

### Умножение матриц

```
! произведение матрицы на матрицу
real :: A(N, M), B(M, K), C(N, K)
C = MatMul (A, B) ! [NxM] * [MxK] = [N x K]

! произведение вектора-строки на матрицу
real :: A(M), B(M, K), C(K)
C = MatMul (A, B) ! [M] * [MxK] = [K]

! произведение матрицы на вектор-столбец
real :: A(N, M), B(M), C(N)
C = MatMul (A, B) ! [NxM] * [M] = [N]

! произведение вектора-столбца на вектор-строку
real :: A(N, 1), B(1, M), C(N, M)
C = MatMul (A, B) ! [Nx1] * [1xM] = [NxM]

! Произведение j - ого столбца матрицы на i-ую строку матрицы (внешним произведением).
real :: A(N, K), B(L, M), C(N, M)
C = MatMul(A(:, j:j), B(i:i, :)) ! [Nx1] * [1xM] = [NxM]

! Разделить массив на положительные и остальные элементы.
real, allocatable :: A(:)
logical, allocatable :: Pos(:)

Pos = A > 0 ! Маска
N = Count(Pos) ! кол-во положительных элементов
A = [Pack(A, Pos), Pack(A, .not. Pos)] ! в первой части массива положительные элементы, во второй - отрицательные
call Sort(A(1:N))

! сортировка каждого четного эл-та
call Sort(A(::2)) ! A(1:N:2) элементы с 1 по N с шагом 2

```

### Сечения

```
A (:, 1) = 0 - сплошная (contiguous) - первый столбец
A (1, :) = 0 - не сплошная, т.к. в памяти элементы хранятся по столбцам - строка

A(2:Mi - 1, 2:Mj - 1) = 2 - не сплошной

Триплет = [i]:[j][:[k]]
i - откуда
j -куда
k - шаг
A(4:8:2)
A(:) - от первого до последнего
```
