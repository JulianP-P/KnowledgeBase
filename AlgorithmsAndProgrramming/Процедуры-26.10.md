environment Procudure
## Назначение
- разбиение исходной задачи
- устранение дублирование кода
- поторное использование написанного кода
- бибилиотеки программ и функций
- раздельное написание программ

### Виды процедур
1. Модули
```
module имя
...
contains
  модульные процедуры
end module
```
- Модульные процедуры пишутся после оператора `contains`
- обладают явным интерфейсом
- пример модуль 'environments'
- имеют доступ ко всем объекта модуля
- могут содержать другие внутренние процедуры 
2. Головная программа 
```
program имя
...
contains
  внутренние процедуры 
end
```
- Модульные процедуры пишутся после оператора `contains`
- обладают явным интерфейсом
- не могут
3. Внешние процедуры
- описываются отдельно от головной программы или других файлах
- обладают неявным интерфейсом
- могут содержать другие внутренние процедуры 
- обмен данными с головной программой происходит посредством формальных параметров
```
subroutine имя finction
...
contains
  внутренние процедуры 
end
```
Может содержать другие внутренние процедуры.

4. Внутренние процедуры 
- описываются в головной программе после оператора 'contains'
- обладают явным интерфейсом
- имеют доступ ко всем объектам головной программы
- не могут содержать другие внутренние процедуры 


Отличие процедуры, функции и подпрограммы - функция возвращает какое-то значение, подпрограмма - не возвращает, процедура - это и функция и подпрограмма.

### Функции
```
тип function имя_функции (формальные параметры)
  типы формальных параметров
  типы внутрненних переменных
*пустая строка*
  исполняемые операторы
  имя_функции = вычисленное значение
end function имя_функции
```
Формальные параметры - входящие параметры

Результатом может выступать также переменная описанная в операторе 'result' после объявления функции.

Если в процедуре меньше трех операторов, то ее не заводим

При вызове функции должны соответствовать:
1. тип функции и тип переменной, которой присваивается результат функции 
2. тип формальных и фактических параметров 
### Подпрограммы

```
subroutine имя_подпрограммы (формальные параметры)
  типы формальных параметров
  типы внутрненних переменных
*пустая строка*
  операторы описания
  исполняемые операторы
end subroutine имя_подпрограммы

#вызов подпрограммы
program sub
  call table(4, 7, "*")
end

subroutine table(M, N, CH)
  ...
end subroutine
```
recursive - 

#### внутренние переменные
Внутренние переменные доступны и используются внутри процедуры

Внутренние переменные получившие инициализацию являются статическими, т. е. память выделяется на этапе компиляции (неявно обладают атрибутом static)

Инициализация означает, что значение переменной находится уже в исполняемом коде, т.е. это НЕ объявление переменной и операция присваивания

Атрибут automatic устанавливает переменные автоматически, т.е. память выделяется во время работы программы (не можем эту переменную сразу инициализировать)

# Передача параметров

1) входные, intent(in)
2) выходные, intent(out)
3) входные/выходные intent(inout)

По умолчанию все параметры имеют атрибут inout, т.к. передаются по ссылке (адресу)

### Вид связи intent(in)
Параметры принимают значение от соответствующего фактического параметра и не могут изменяться при выполнении процедуры.

Соответствующими фактическими параметрами могут быть выражения, переменные, значения, константы.
### Вид связи intent(out)
Параметры передают свое значение соответствущему фактическому параметру и предназначены для вывода данных из процедуры.

Соответствующий фактический параметр должен быть переменной.

### Вид связи intent(inout)
Параметры могут как приниать значения от фактического параметра, так и передавать данные в фактический параметр.

Соответствующий фактический параметр должен быть переменной.
### Optional параметры
Атрибут `optional` устанавливает формальные параметры необязательными.

Функция `present` проверяет присутствие необязательного параметра при вызове процедуры.

При отсутствии проверки функцией `present` возможны ошибки выполнения для параметров с видом связи intent(out, inout).

Процедура должна иметь явный интерфейс.
**Дополнительные параметры используются только в острой необходимости**

### Область видимости
Объекты описанные в головной программе доступны во внутренних процедурах, недоступны во внешних.

Объекты описанные во внутренней, внешней процедурах доступны только в них самих.

При совпадении имен объектов головной программы и внутренней или внешней процедур, объекты являются разными.

# Побочные эффект

Символ - имя процедуры или переменной, к которому мы обращаемся из исполняемого кода

Интерфейс - указываем там тип функции и тип передаваемых параметров (это не интерфейс из ооп)
### Оператор interface
Определяет явно заданный интерфейс.
Используется для внешних процедур.
Внутренние процедуры обладают явно заданным интерфейсом.
```
interface
 тип имя_функции(формальные параметры)
 тип формальных параметров
 конец описания функции
end interface
```
Пример
```
interface RAND
  elemental function scalar_rand(x)
    real, intent(in) :: x
    real scalar_rand
  end function scalar_rand

  function vector_random(x)
    real x(:)
    real vector_randok(size(x))
  end function vector_random
end interface RAND
```
Существуют две функции `scalar_rand` и `vector_random`. Нельзя обращаться к ним по имени, т.к. они объединены в одном интерфейсе. Их можно вызывать только по названию интерфейса. В зависисоти от передаваемого параметра будет вызываться или одна функция или другая.

Однако, при `Real AA(10, 10), A(10, 10); A = RAND(AA)`, будет вызвана функция `scalar_rand`, хотя ни `scalar_rand`, ни `vector_random` не принимают двумерные массивы. Почему будет вызвана функция `scalar_rand`? Из-за `elemental`.

При `A(:,1) = RAND(AA(6:10,2))` будет вызвана функция `vector_random`.

### Оператор return
Вернуть управление вызывающей процедуре или головной программе.

### Процедуры как параметры
Оператор `external` объявляет, что перечисленные внешние процедуры передаются как параметры.
Если хотим передавать стандартные функции как параметры, то нет смысла писать

Оператор `intrinsic` объявляет, что перечисленные стандартные процедуры передаются как параметры.
```
program param_funct
 intrinsic sin
 write(*,*) f(0.5, sin)
end
```

Вместо указания функции в операторе external можно использовать блок interface.

`symbol unresolt`

### Чистые процедуры
Чистые процеддуры - процедуры без побочных эффектов

Нужно стремиться к чистому программированию

Чистые процедуры могут вызывать только чистые процедуры

Все встроенные функции являются чистыми

Все процедуры обработки данных нужно объявлять simple или pure

Ключевое слово pure объявляет процедуру чистой.

Для чистых процедур характерно
- все формальные параметры функций имеют вид связи intent(in);
- все формальные параметры подпрограмм имеют вид связи intent(in, out или inout);
- отсутствуют операторы В/В, stop.

### Элементные процедуры
```
pure elemental function F(p, x)
  real(R_) p, x
  real(R_) F
  intent(in) p, x
  real(R_), parameter :: q = 2.75_R_
  F = sqrt(p + q * x**2) / (3 + p*x + q*x**2) ! векторизация

```
Вместо скаляров p и x можно передавать в функцию массивы
Пример
```
interface RAND
  elemental function scalar_rand(x)
    real, intent(in) :: x
    real scalar_rand
  end function scalar_rand

  function vector_random(x)
    real x(:)
    real vector_randok(size(x))
  end function vector_random
end interface RAND
```
При `Real AA(10, 10), A(10, 10); A = RAND(AA)`, будет вызвана функция `scalar_rand`, хотя ни `scalar_rand`, ни `vector_random` не принимают двумерные массивы. Почему будет вызвана функция `scalar_rand`? Из-за `elemental`.
