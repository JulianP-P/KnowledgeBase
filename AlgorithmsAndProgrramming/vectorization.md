## Основы векторизации кода
Регулярное программирование позволяет задействовать векторизацию

#### Показатели качества кода со стороны пользователя:
- Производительность кода Perf или участка кода `Perf = 1/T [c^-1]` (code perfomance) - количественный показатель
- потребляемая память Mem (memory consumption) - количественный показатель
- Поддержка современных микроархитектур - качественный показатель

#### Показатели качества кода со стороны разработчика:
- Сложность кода Compl (code complexity) - количественный показатель `Compl = LOC, Compl = Сycl`
- Число строк кода LOC (Lines of a code)
- Цикломантическая сложность кода Cycl (cyclomatic complexity of a code) - количество линейно независимых маршрутов через программный код

#### Эффективность кода
- Интегральный показатель
- Относится и к разработчику и к пользователю
- `Prod = Perf / Compl = 1 / (T * Compl)`
- В знаменатель можно добавить mem, ttm, стоимость разработки

Эволюция архитектур
- single core
- hyper-threading
- doal core
- multi core
- many core (создаются специализированные ядра, у которых есть своя задач, например, обработка видео)

### Архитектуры SIMD современных ядер
Регистровый файл (Register file) - данные, с котоорыми может работать оборудование, размещенное на процессоре.
Процессор умеет работать только с регистровым файлом.

Кэш-память - СОЗУ (сверхоперативное запоминающее устройство)

Для ускорения операций придумали векторный блок. Он мог работать сразу с несколькими числами в модуле с плавающей запятой или АЛУ (АЛУ - арифметикоскладывающее устройство)

SIMD - одна инструкция над множеством данных

**Чтобы внедрить векторизацию потребовалось:**
- векторное алу и векторный модуль с плавующей запятой (в каждое ядро)
- векторно-регистровый файл
- расширить систему команд

Пиковая производительность - теоретическая произовдительность выставляемая процессором. 

FLOPS - операции с плавающей запятой в секунду

Реальная производительность - производительность доставляемая реальным приложеением

#### Эффективность процессора
-`Prod = Perf/TDP`
- Perf производительность (perfomance)
- TDP рассеиваемая мощность (Thermal design power)
- Prod эффектичность (productivity)

#### MMX
- 64 бита
- Ifpp (Itaniu): 64 бита - 2 числа с плавающией запятой

#### 3DNow!
- 64 бита - 2 числа с плавающец запятой

#### SSE (striming sint exceptions)
  - 64 бита - 2 числа с плавающей точкой
 
#### SSE2
  - 64 бита - 2 числа с плавающей точкой

#### SSE3
  - 64 бита - 2 числа с плавающей точкой

#### SSE4
  - 128 бит - 4 числа с плавающей точкой

#### AVX - дополнительные векторные расширения
- 256 бит - 8 чисел с плавающей запятой
  
#### AVX2
- 256 бит - 8 чисел с плавающей запятой

#### AVX-512
- 512 бит - 16 чисел с плавающей запятой

Порядок векторицазии:
- Формирование из скалярных данных - векторные
- Применение к веторным регистрам векторной операций
- сохранение результата из векторного регистра в память

Зависимость чтения-после-записи относительно влияет на векторизацию

Для векторизации не должно быть условных ветвлений циклов.
```
! Не будет векторизоваться
do i = 5, N
  if(mod(i, 10) == 0) &
    A(i) = A(i-5) + 1
```

stride - шаг (для векторизации)

перекрытие по памяти - memory overlapping

ssi требует выравнивание на 64 байт
avx512 на 128
